## HTTP GET
- HTTP Request Message의 `Header 부분`에 url이 담겨서 전송된다. 
- url의 `?`뒤에 데이터가 붙어서 request를 보낸다.
- 때문에 전송 데이터의 크기가 제한적이고, 보안 측면에서 좋지 않다.
- 서버에서 데이터를 `가져올 때` 사용한다. (SELECT)
- 브라우저에서 Caching할 수 있다.
## HTTP POST
- HTTP Request Message의 `Body 부분`에 데이터가 담겨서 전송된다. 
- GET 방식에 비해 데이터 크기가 크고 보안면에서 낫다.
- 서버의 값이나 상태를 `변경/추가`하고자 할 때 사용한다.
</br>

# HTTP의 문제점
### 1. 평문 통신이기 때문에 도청이 가능하다.
통신 경로 상에서 엿볼 수 있고, 패킷을 수집하는 것만으로도 도청할 수 있다.  
평문 통신의 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.
#### 보완 방법
- 통신 자체를 암호화 : `SSL(Secure Socket Layer)` or `TLS(Transport Layer Security)`와 같은 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화
- 콘텐츠를 암호화 : HTTP 메시지에 포함되는 콘텐츠만 암호화한다. 이 메시지를 받은 측에서는 해독하여 출력하는 처리가 필요하다.
### 2. 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
HTTP 통신은 상대가 누구인지 확인하지 않는다.  
누구든지 request를 보낼 수 있기 때문에 상대가 누구든지 request를 받으면 response를 반환한다.
#### 문제점 
- request를 보낸 곳의 서버가 원래 보내려던 서버인지 확인할 수 없다.
- response를 보낸 곳의 클라이언트가 원래 보내려던 클라이언트인지 확인 할 수 없다.
- 통신 상대가 접근이 허가된 상대인지 확인할 수 없다.
- 의미 없는 request도 수신한다. &rarr; Dos 공격 방지 불가
#### 보완 방법
`SSL`를 통해 상대를 확인할 수 있다. 상대를 확인하는 수단으로 증명서를 제공한다.  
증명서는 제 3자 기관에 의해 발행되기 때문에 서버, 클라이언트가 실재하는 사실을 증명한다.
### 3. 완전성을 증명할 수 없기 때문에 변조가 가능하다.
수신자가 받은 내용이 송신자가 보낸 내용과 일치한다는 것을 보장할 수 없다.  
request, response를 보낸 후, 수신 도중에 누군가가 변조시키더라도 확인할 수 없다. (중간자 공격, Man-in-the-Middle)
#### 보완 방법
- `MD5`, `SHA-` 등의 해시 값을 확인하거나 파일의 디지털 서명을 확인한다. 
- 위 방법은 확실히 방지할 수 없기 때문에 `SSL`를 사용해야 한다.
</br>

# HTTPS
`HTTPS` : SSL의 껍질을 덮어써서 암호화, 인증, 완전성 보호를 더한 HTTP  
- 새로운 계층의 프로토콜이 아닌, HTTP 소켓 부분을 `SSL(Secure Socket Layer)` or `TLS(Transport Layer Security)` 프로토콜로 대체한 것이다.
- HTTPS의 SSL은 공통키 암호화 방식과 공개키 암호화 방식을 결합한 하이브리드 암호 시스템을 사용한다.
- 원래의 HTTP : HTTP ↔ TCP
- HTTPS : HTTP ↔ SSL ↔ TCP

</br>

----
#### 출처  
https://github.com/JaeYeopHan/Interview_Question_for_Beginner
