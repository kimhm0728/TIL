# Array vs LinkedList
## Array  
논리적 저장 순서와 물리적 저장 순서가 `일치`하는 자료구조.  
인덱스로 해당 원소에 접근할 수 있기 때문에  
찾고자 하는 원소의 인덱스 값을 알고 있으면 `O(1)`에 해당 원소로 접근할 수 있다.  

`삭제`, `삽입`의 경우 원소들의 인덱스를 1씩 shift 해줘야 하므로 `O(n)`의 시간이 요구된다.
## Linked List
Array 삭제, 삽입의 문제점을 해결한 자료구조.  
각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다.  
그러므로 이 부분만 다른 값으로 바꿔주면 `삭제`와 `삽입`을 `O(1)`만에 해결할 수 있다.   
논리적 저장 순서와 물리적 저장 순서가 `일치하지 않기` 때문에  
어떤 원소를 찾기 위해서는 첫번째 원소부터 다 확인해봐야 하므로 `O(n)`의 시간이 발생한다.
# Stack vs Queue
## Stack
`Last In First Out`(LIFO)의 특징을 가지는 자료구조.  
즉 나중에 들어간 원소가 가장 먼저 나온다.
## Queue
`First In First Out`(FIFO)의 특징을 가지는 자료구조.
즉 먼저 들어간 원소가 가장 먼저 나온다.
# Tree
지금까지 설명한 자료구조와는 다르게, 선형 자료구조가 아닌 `비선형` 자료구조다.  
계층적 관계를 표현하는 자료구조다.
### 구성 요소
- Node(노드) : 트리를 구성하는 각각의 요소
- Edge(간선) : 노드와 노드를 연결하는 선
- Root Node(루트 노드) : 부모 노드가 없이 최상위에 있는 노드
- Leaf Node(Terminal Node, 단말 노드) : 자식이 없는 노드
- Internal Node(내부 노드, 비단말 노드) : 자식을 가지는 노드(루트 노드 포함)
### Binary Tree(이진 트리)
루트 노드를 중심으로 두 개의 서브트리로 나뉘어지는 트리.  
나뉘어진 두 서브 트리도 모두 이진 트리어야 한다.  
즉, 모든 노드의 자식 노드가 0~2개인 트리를 말한다.    
- Level(레벨) : 각 층별로 매긴 숫자. 루트 노드의 레벨부터 0으로 시작한다. 트리의 최고 레벨을 트리의 height(높이)라고 한다.
- 이진 트리를 배열로 구성하고 루트 노드가 1부터 시작할 때, parent(i) = i/2 , left_child(i) = 2i , right_child(i) = 2i + 1
#### Perfect Binary Tree (포화 이진 트리)
모든 레벨이 꽉 찬(자식이 두 개인) 이진 트리.
#### Complete Binary Tree (완전 이진 트리)
위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리.
#### Full Binary Tree (정 이진 트리)
모든 노드가 0개 혹은 2개의 자식 노드만을 가지는 이진 트리.
#### BST(Binary Search Tree)
아래 규칙을 갖는 이진 트리.
- 규칙 1. 이진 탐색 트리의 노드에 저장된 값(key)는 `유일`하다.
- 규칙 2. 부모의 키가 `왼쪽 자식 노드`의 키보다 `크다`.
- 규칙 3. 부모의 키가 `오른쪽 자식 노드`의 키보다 `작다`.
- 규칙 4. 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.
이진 탐색 트리의 탐색 연산은 O(logn) = O(h)의 시간 복잡도를 갖는다. 
저장 순서에 따라 한 쪽으로만 노드가 추가되어 편향 트리(Skewed Tree)가 될 수 있다.
이럴 경우 O(n)의 시간 복잡도가 되며, 배열보다 메모리는 많고 시간 복잡도는 같아질 수 있다.
이를 해결하기 위해 트리 구조를 재조정하는 Rebalancing 기법이 등장했다. (Red-Black Tree)
# Binary Heap  
`배열`에 기반한 Complete Binary Tree의 형식을 가지는 자료구조다.  
1번째 인덱스부터 루트 노드가 시작된다.
- 최대 힙(Max Heap) : 각 노드의 값이 자식보다 크거나 같음. 루트 노드의 값이 가장 크므로 최대값을 찾기 위해 `O(1)`이 소요된다.
- 최소 힙(Min Heap) : 각 노드의 값이 자식보다 작거나 같음. 루트 노드의 값이 가장 작으므로 최소값을 찾기 위해 `O(1)`이 소요된다.
### Heapify
heap에서 루트 노드를 삭제한 후, heap의 구조를 계속 유지해야 한다.    
여기서 heap의 맨 마지막 노드를 루트 노드로 대체시킨 후, heapify 과정을 통해 heap 구조를 유지한다.  
이 경우 O(logn)를 소요하여 최대값 또는 최소값에 접근한다.  
# Red-Black Tree
BST를 기반으로 하는 트리 형식 자료구조이다.  
탐색, 삽입, 삭제에 `O(logn)`의 시간 복잡도가 소요된다.  
동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄인다.  
#### Red-Black Tree 성질
- 각 노드는 Red/Black의 색을 갖는다.
- 루트 노드, 리프 노드의 색은 Black이다.
- 색이 Red인 노드의 자식은 Black 이다.
- 각 노드로부터 리프 노드까지는 같은 수의 Black 노드를 포함해야 한다. (`Black-Height`)
- 루트 노드부터 리프 노드까지의 최소 경로, 최대 경로의 차이는 2 이하다. (Balanced 상태)
- 노드의 자식이 없는 경우 NIL 값을 저장한다. (NIL == 리프 노드)
#### 삽입
BST의 특성을 유지하면서 노드를 삽입한다.  
Black-Height 유지를 위해 삽입된 노드의 색을 Red로 지정한다.  
RBT 특성 위배시 노드 색을 조정하고,  
Black-Height가 위배되었다면 rotation을 통해 heightf를 조정한다.  
#### 삭제
BST의 특성을 유지하면서 노드를 삭제한다.  
삭제된 노드의 색이 Black이라면 Black-Height가 변경되었기 때문에 그 경로에 Black 노드가 하나 추가되도록 rotation한다.  
삭제된 노드의 색이 Red라면 Black-Height가 위배되지 않으므로 그대로 유지된다.  
# Hash Table
배열을 사용하고 특정 값을 찾을 때 `고유의 인덱스`로 접근하므로 평균적으로 O(1)이 소요된다. (충돌 시 O(1) 이상)  
해시 함수를 이용해 데이터와 연관된 고유한 숫자를 만들고, 이를 인덱스로 사용한다.  
그 데이터만의 고유한 위치익 때문에 삽입, 삭제 연산시 추가적인 연산이 필요하지 않다.  
### Hash Function
저장되는 key값을 해시 하수를 통해 작은 범위의 값들로 바꿔준다. 이 고유한 숫자를 hashcode라고 한다.  
서로 다른 두 개의 키가 같은 인덱스로 해싱되는 충돌(Collision)을 최소화하기 위해서는 좋은 해시 함수가 필요하다.  
#### 좋은 해시 함수
키의 일부분을 참조하지 않고 키 전체를 참조하여 해쉬 값을 만들어 내야한다. 이는 키가 어떤 특성을 가지고 있느냐에 따라 달라진다.  
무조건 키와 해시 코드를 1:1로 만드는 것보다는(array와 다를 바 없고 메모리를 차지 함) Collision(충돌)을 최소화해야 한다.  
### 충돌 해결
#### Open Address 방식(개방주소법)
해시 충돌이 발생하면, 다른 해시 버킷에 해당 자료를 삽입하는 방식이다.
- Linear Probing : 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다.
- Quadratic probing : 2차 함수를 이용해 탐색할 위치를 찾는다.
- Double hashing probing : 하나의 해시 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당한다. 비교적 연산량이 많다.
#### Seprarate Chaining 방식(분리 연결법)
- Linked List 사용 : 각각의 버킷을 연결리스트로 만들어 충돌이 발생하면 해당 버킷의 뒤에 추가하는 방식이다.
- Tree 사용(RBT) : Linked List 대신 Tree를 사용한다. 데이터 개수가 적다면, 메모리 측면에서 효율적인 Linked List를 사용한다.
#### Open Address vs Separate Chaining
Open Address는 연속된 공간을 사용하기 때문에 캐시 효율이 높다. 즉, 데이터가 적다면 Open Address가 성능이 더 좋다.  
Open Address는 버킷을 계속해서 사용하지만, Separater Chaining은 고정된 버킷에 데이터를 추가해가기 때문에 Separate Chaining이 테이블 확장을 보다 늦출 수 있다.
#### 해시 버킷 동적 확장(Resize)
해시 버킷의 개수가 적다면 메모리 사용량이 적지만, 충돌 횟수가 많아져 성능이 떨어진다.  
그래서 HashMap에서는 key-value쌍이 일정 개수(75%, load factor) 이상이 되면 해시 버킷의 개수를 두 배로 늘린다.  
# Graph
정점(Vertex)과 간선(Edge)의 집합인 자료구조다. (트리는 사이클이 허용되지 않는 그래프)
- Undirected Graph : 간선의 연결관계에서 방향성이 없는 그래프
- Directed Graph : 간선끼리의 방향성이 포함되어 있는 그래프
- Degree : 각 정점에 연결된 간선의 개수. Directed Graph에서는 OutDegree/Indegree로 구분한다.
- Weight Graph : 간선에 가중치 정보를 두어서 구성한 그래프
#### 구현 방법
- 인접 행렬(정방 행렬을 사용) : O(1)로 정점 간의 연결 관계를 파악할 수 있다. 간선 개수와는 무관하게 V^2의 공간 복잡도를 가지므로 밀집 그래프에 적합하다.  
- 인접 리스트(연결 리스트 사용) : 정점의 리스트를 하나하나 확인해봐야 하므로 정점 간의 연결 관계 파악이 오래 걸린다. E+V의 공간 복잡도 가지므로 희소 그래프에 적합하다.
#### 탐색 
- 깊이 우선 탐색 (Depth First Search, DFS) : 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더이상 연결될 수 있는 정점이 없으면 바로 그 전 단계의 정점으로 돌아가서 다시 확인한다. Stack을 사용한다.
- 너비 우선 탐색 (Breadth First Search, BFS) : 한 번에 연결되어 있는 모든 정점으로 나아간다. Queue를 사용한다.
시간 복잡도 : O(V+E)
### Minimum Spanning Tree
그래프에서 간선의 가중치의 합이 최소인 트리.   
spanning tree : 모든 정점이 사이클 없이 연결된 형태
#### Kruskal Algorithm
1. 초기화 : 정점들만으로 그래프를 구성한다.
2. 가중치가 제일 작은 간선부터 검토한다.
3. 사이클이 생기지 않는다면, 그 간선을 그래프에 추가한다.
4. 정점 - 1 만큼 간선을 연결했다면 종료한다.
사이클 생성 여부는 Union-Find 알고리즘을 통해 판단한다.
시간 복잡도 : O(ElogE)
#### Prim Algorithm
1. 초기화 : 한 개의 정점으로 이루어진 그래프를 구성한다.
2. 그래프 내부에 있는 정점에서 외부의 정점을 연결하는 간선 중 가장 가중치가 작은 정점을 추가한다.
3. 모든 정점이 연결되면 종료한다.
시간 복잡도 : O(ElogV)
-----
#### 출처  
https://github.com/JaeYeopHan/Interview_Question_for_Beginner
